From f79199b8d6bc4e44d613b5b9d91492f45275d76f Mon Sep 17 00:00:00 2001
From: Mahyar Koshkouei <mahyar.koshkouei@gmail.com>
Date: Wed, 22 Nov 2017 23:42:20 +0000
Subject: [PATCH 1/1] Remove UTF-8 functions

Fixed an issue whereby Retroarch would not compile if a toolchain did
not contain the appropriate UTF-8 functions.

Not for submission.

Signed-off-by: Mahyar Koshkouei <mahyar.koshkouei@gmail.com>
---
 libretro-common/encodings/encoding_utf.c | 179 +++++--------------------------
 1 file changed, 29 insertions(+), 150 deletions(-)

diff --git a/libretro-common/encodings/encoding_utf.c b/libretro-common/encodings/encoding_utf.c
index 2148fcb47..e2048a57b 100644
--- a/libretro-common/encodings/encoding_utf.c
+++ b/libretro-common/encodings/encoding_utf.c
@@ -20,6 +20,7 @@
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
 
+#include <stdio.h>
 #include <stdint.h>
 #include <stdlib.h>
 #include <stddef.h>
@@ -164,13 +165,13 @@ size_t utf8cpy(char *d, size_t d_len, const char *s, size_t chars)
    while (*sb && chars-- > 0)
    {
       sb++;
-      while ((*sb & 0xC0) == 0x80) sb++;
+      while ((*sb&0xC0) == 0x80) sb++;
    }
 
    if ((size_t)(sb - sb_org) > d_len-1 /* NUL */)
    {
       sb = sb_org + d_len-1;
-      while ((*sb & 0xC0) == 0x80) sb--;
+      while ((*sb&0xC0) == 0x80) sb--;
    }
 
    memcpy(d, sb_org, sb-sb_org);
@@ -187,7 +188,7 @@ const char *utf8skip(const char *str, size_t chars)
    do
    {
       strb++;
-      while ((*strb & 0xC0)==0x80) strb++;
+      while ((*strb&0xC0)==0x80) strb++;
       chars--;
    } while(chars);
    return (const char*)strb;
@@ -218,22 +219,23 @@ static INLINE uint8_t utf8_walkbyte(const char **string)
 uint32_t utf8_walk(const char **string)
 {
    uint8_t first = utf8_walkbyte(string);
-   uint32_t ret  = 0;
+   uint32_t ret;
 
-   if (first < 128)
+   if (first<128)
       return first;
 
-   ret    = (ret << 6) | (utf8_walkbyte(string) & 0x3F);
+   ret = 0;
+   ret = (ret<<6) | (utf8_walkbyte(string)    & 0x3F);
    if (first >= 0xE0)
-      ret = (ret << 6) | (utf8_walkbyte(string) & 0x3F);
+      ret = (ret<<6) | (utf8_walkbyte(string) & 0x3F);
    if (first >= 0xF0)
-      ret = (ret << 6) | (utf8_walkbyte(string) & 0x3F);
+      ret = (ret<<6) | (utf8_walkbyte(string) & 0x3F);
 
    if (first >= 0xF0)
-      return ret | (first & 7) << 18;
+      return ret | (first&7)<<18;
    if (first >= 0xE0)
-      return ret | (first & 15) << 12;
-   return ret | (first & 31) << 6;
+      return ret | (first&15)<<12;
+   return ret | (first&31)<<6;
 }
 
 static bool utf16_to_char(uint8_t **utf_data,
@@ -272,21 +274,15 @@ bool utf16_to_char_string(const uint16_t *in, char *s, size_t len)
 }
 
 /* Returned pointer MUST be freed by the caller if non-NULL. */
-static char* mb_to_mb_string_alloc(const char *str,
-      enum CodePage cp_in, enum CodePage cp_out)
+static char* mb_to_mb_string_alloc(const char *str, enum CodePage cp_in, enum CodePage cp_out)
 {
-   char *path_buf         = NULL;
+   char *path_buf = NULL;
    wchar_t *path_buf_wide = NULL;
-   int path_buf_len       = 0;
-   int path_buf_wide_len  = 0;
+   int path_buf_len = 0;
+   int path_buf_wide_len = 0;
 
    if (!str || !*str)
       return NULL;
-    
-   (void)path_buf;
-   (void)path_buf_wide;
-   (void)path_buf_len;
-   (void)path_buf_wide_len;
 
 #if !defined(_WIN32) || defined(_XBOX)
    /* assume string needs no modification if not on Windows */
@@ -301,49 +297,45 @@ static char* mb_to_mb_string_alloc(const char *str,
 
    if (path_buf_wide_len)
    {
-      path_buf_wide = (wchar_t*)
-         calloc(path_buf_wide_len + sizeof(wchar_t), sizeof(wchar_t));
+      path_buf_wide = (wchar_t*)calloc(path_buf_wide_len + sizeof(wchar_t), sizeof(wchar_t));
 
       if (path_buf_wide)
       {
-         MultiByteToWideChar(cp_in, 0,
-               str, -1, path_buf_wide, path_buf_wide_len);
+         MultiByteToWideChar(cp_in, 0, str, -1, path_buf_wide, path_buf_wide_len);
 
          if (*path_buf_wide)
          {
-            path_buf_len = WideCharToMultiByte(cp_out, 0,
-                  path_buf_wide, -1, NULL, 0, NULL, NULL);
+            path_buf_len = WideCharToMultiByte(cp_out, 0, path_buf_wide, -1, NULL, 0, NULL, NULL);
 
             if (path_buf_len)
             {
-               path_buf = (char*)
-                  calloc(path_buf_len + sizeof(char), sizeof(char));
+               path_buf = (char*)calloc(path_buf_len + sizeof(char), sizeof(char));
 
                if (path_buf)
                {
-                  WideCharToMultiByte(cp_out, 0,
-                        path_buf_wide, -1, path_buf,
-                        path_buf_len, NULL, NULL);
+                  WideCharToMultiByte(cp_out, 0, path_buf_wide, -1, path_buf, path_buf_len, NULL, NULL);
 
                   free(path_buf_wide);
 
                   if (*path_buf)
                      return path_buf;
-
-                  free(path_buf);
-                  return NULL;
+                  else
+                  {
+                     free(path_buf);
+                     return NULL;
+                  }
                }
             }
          }
       }
    }
+#endif
+#endif
 
    if (path_buf_wide)
       free(path_buf_wide);
 
    return NULL;
-#endif
-#endif
 }
 
 /* Returned pointer MUST be freed by the caller if non-NULL. */
@@ -358,116 +350,3 @@ char* local_to_utf8_string_alloc(const char *str)
    return mb_to_mb_string_alloc(str, CODEPAGE_LOCAL, CODEPAGE_UTF8);
 }
 
-/* Returned pointer MUST be freed by the caller if non-NULL. */
-wchar_t* utf8_to_utf16_string_alloc(const char *str)
-{
-#ifdef _WIN32
-   int len = 0;
-   int out_len = 0;
-#else
-   size_t len = 0;
-   size_t out_len = 0;
-#endif
-   wchar_t *buf = NULL;
-
-   if (!str || !*str)
-      return NULL;
-
-#ifdef _WIN32
-   len = MultiByteToWideChar(CP_UTF8, 0, str, -1, NULL, 0);
-
-   if (len)
-   {
-      buf = (wchar_t*)calloc(len, sizeof(wchar_t));
-      
-      if (!buf)
-         return NULL;
-
-      out_len = MultiByteToWideChar(CP_UTF8, 0, str, -1, buf, len);
-   }
-
-   if (out_len < 0)
-   {
-      free(buf);
-      return NULL;
-   }
-#else
-   /* NOTE: For now, assume non-Windows platforms' locale is already UTF-8. */
-   len = mbstowcs(NULL, str, 0) + 1;
-
-   if (len)
-   {
-      buf = (wchar_t*)calloc(len, sizeof(wchar_t));
-      
-      if (!buf)
-         return NULL;
-
-      out_len = mbstowcs(buf, str, len);
-   }
-
-   if (out_len == (size_t)-1)
-   {
-      free(buf);
-      return NULL;
-   }
-#endif
-
-   return buf;
-}
-
-/* Returned pointer MUST be freed by the caller if non-NULL. */
-char* utf16_to_utf8_string_alloc(const wchar_t *str)
-{
-#ifdef _WIN32
-   int len = 0;
-   int out_len = 0;
-#else
-   size_t len = 0;
-   size_t out_len = 0;
-#endif
-   char *buf = NULL;
-
-   if (!str || !*str)
-      return NULL;
-
-#ifdef _WIN32
-   len = WideCharToMultiByte(CP_UTF8, 0, str, -1, NULL, 0, NULL, NULL);
-
-   if (len)
-   {
-      buf = (char*)calloc(len, sizeof(char));
-
-      if (!buf)
-         return NULL;
-
-      out_len = WideCharToMultiByte(CP_UTF8, 0, str, -1, buf, len, NULL, NULL);
-   }
-
-   if (out_len < 0)
-   {
-      free(buf);
-      return NULL;
-   }
-#else
-   /* NOTE: For now, assume non-Windows platforms' locale is already UTF-8. */
-   len = wcstombs(NULL, str, 0) + 1;
-
-   if (len)
-   {
-      buf = (char*)calloc(len, sizeof(char));
-
-      if (!buf)
-         return NULL;
-
-      out_len = wcstombs(buf, str, len);
-   }
-
-   if (out_len == (size_t)-1)
-   {
-      free(buf);
-      return NULL;
-   }
-#endif
-
-   return buf;
-}
-- 
2.15.0

